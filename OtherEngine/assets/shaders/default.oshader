vertex [mesh : default] {

  out vec3 fviewpoint;

  out vec3 foe_position;
  out vec3 foe_normal;
  out vec2 foe_texcoords;
  
  void main() {
    mat4 model = models[gl_InstanceID];
    mat3 normal_model = mat3(transpose(inverse(model)));
    vec4 world_pos = model * vec4(voe_position , 1.0); 

    gl_Position = projection * view * world_pos;


    material = materials[gl_InstanceID];
    fviewpoint = viewpoint.xyz;

    foe_position = world_pos.xyz;
    foe_normal = normal_model * voe_normal;
    foe_texcoords = voe_uvs;

  };

}

fragment {

  in vec3 fviewpoint;

  in vec3 foe_position;
  in vec3 foe_normal;
  in vec2 foe_texcoords;

  out vec4 FragColor;

  vec3 CalcDirectionLight(DirectionLight light , vec3 normal , vec3 view_dir , vec3 diffuse , float specular) {
    vec3 color = light.color.rgb;

    // diffuse
    vec3 light_dir = normalize(-light.direction.xyz);
    vec3 diff = max(dot(normal , light_dir) , 0.0) * diffuse * color;

    // specular 
    vec3 reflect_dir = reflect(-light_dir , normal);
    float s = pow(max(dot(view_dir , reflect_dir) , 0.0) , specular);
    vec3 spec = color * s;

    return (diff + spec);
  }

  vec3 CalcPointLight(PointLight light , vec3 normal , vec3 frag_pos , vec3 view_dir , vec3 diffuse , float specular) {
    vec3 color = light.color.rgb;

    // diffuse
    vec3 light_dir = normalize(light.position.xyz - frag_pos);
    vec3 diff = max(dot(normal , light_dir) , 0.0) * diffuse * color;

    // specular
    vec3 halfway = normalize(light_dir + view_dir);
    float s = pow(max(dot(normal , halfway) , 0.0) , specular);
    vec3 spec = color * s;

    // attenuation
    float dist = length(light.position.xyz - frag_pos);
    float attenuation = 1.0 / (1.0 + light.linear * dist + light.quadratic * dist * dist);

    diff = diff * attenuation;
    spec = spec * attenuation;

    return (diff + spec);
  }

  void main () {
    vec3 norm = normalize(foe_normal);
    vec3 view_dir = normalize(fviewpoint - foe_position);

    vec3 frag_pos = foe_position; 
    vec3 normal = foe_normal; 
    vec3 diffuse = material.color.rgb; 

    /// TODO: figure out how to replace this with material.shininess without insanely bright specular
    //        reflections
    float specular = texture(goe_albedo , foe_texcoords).a;

    /// lights
    vec3 result = diffuse * 0.1;
    
    int i = 0;
    for (; i < num_lights.x;) {
      result = result + CalcDirectionLight(direction_lights[i] , norm , view_dir , diffuse , specular);
      i = i + 1;
    }

    i = 0;
    for (; i < num_lights.y;) {
      result = result + CalcPointLight(point_lights[i] , normal , foe_position , view_dir , diffuse , specular);
      i = i + 1;
    }
      
    ///  final color
    FragColor = vec4(result , 1.f);
  };

}
