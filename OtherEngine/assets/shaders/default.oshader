vertex [mesh : default] {

  out vec3 fviewpoint;

  out vec3 foe_position;
  out vec3 foe_normal;
  
  void main() {
    gl_Position = projection * view * voe_model * vec4(voe_position , 1.0);

    fviewpoint = viewpoint.xyz;

    foe_position = vec3(voe_model * vec4(voe_position , 1.0));
    foe_normal = mat3(transpose(inverse(voe_model))) * voe_normal;
  };

}

fragment {

  in vec3 fviewpoint;

  in vec3 foe_position;
  in vec3 foe_normal;

  out vec4 FragColor;

  vec3 CalcDirLight(DirectionLight light , vec3 normal , vec3 view_dir) {
    vec3 light_dir = normalize(-light.direction.xyz);

    float diff = max(dot(normal , light_dir) , 0.0);
    
    vec3 reflect_dir = reflect(-light_dir , normal);
    float spec = pow(max(dot(view_dir , reflect_dir) , 0.0) , foe_material.shininess);
    
    vec3 ambient = light.direction.rgb * foe_material.diffuse.rgb;
    vec3 diffuse = light.diffuse.rgb * diff * foe_material.diffuse.rgb;
    vec3 specular = light.specular.rgb * spec * foe_material.specular.rgb;
    return (ambient + diffuse + specular);
  }

  vec3 CalcPointLight(PointLight light , vec3 normal , vec3 frag_pos , vec3 view_dir) {
    vec3 light_dir = normalize(light.position.xyz - frag_pos);
    float diff = max(dot(normal , light_dir) , 0.f);

    vec3 reflect_dir = reflect(-light_dir , normal);
    float spec = pow(max(dot(view_dir , reflect_dir) , 0.0) , foe_material.shininess);

    float distance = length(light.position.xyz - frag_pos);
    float attenuation = 1.f / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    vec3 ambient = light.ambient.rgb * foe_material.ambient.rgb * attenuation;
    vec3 diffuse = light.diffuse.rgb * diff * foe_material.diffuse.rgb * attenuation;
    vec3 specular = light.specular.rgb * spec * foe_material.specular.rgb * attenuation;
    
    return (ambient + diffuse + specular);
  }

  void main () {
    /// general data
    vec3 norm = normalize(foe_normal);
    vec3 view_dir = normalize(fviewpoint - foe_position);

    /// lights
    vec3 result = CalcDirLight(direction_light , norm , view_dir);
    // result = result + CalcPointLight(foe_plight , norm , foe_position , view_dir);
      
    ///  final color
    FragColor = vec4(result , 1.f);
  };

}
