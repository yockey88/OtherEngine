vertex [mesh : default] {

  out vec3 fviewpoint;

  out vec3 foe_position;
  out vec3 foe_normal;
  
  void main() {
    gl_Position = projection * view * models[gl_InstanceID] * vec4(voe_position , 1.0);

    fviewpoint = viewpoint.xyz;

    foe_position = vec3(models[gl_InstanceID] * vec4(voe_position , 1.0));
    foe_normal = mat3(transpose(inverse(models[gl_InstanceID]))) * voe_normal;

    material = materials[gl_InstanceID];
  };

}

fragment {

  in vec3 fviewpoint;

  in vec3 foe_position;
  in vec3 foe_normal;

  out vec4 FragColor;
      
  // uniform sampler2D g_position;
  // uniform sampler2D g_normal;
  // uniform sampler2D g_albedo;

  vec3 CalcDirectionLight(DirectionLight light , vec3 normal , vec3 view_dir) {
    vec3 light_dir = normalize(-light.direction.xyz);

    float diff = max(dot(normal , light_dir) , 0.0);
    
    vec3 reflect_dir = reflect(-light_dir , normal);
    float spec = pow(max(dot(view_dir , reflect_dir) , 0.0) , material.shininess);
    
    vec3 ambient = light.ambient.rgb * material.ambient.rgb;
    vec3 diffuse = light.diffuse.rgb * diff * material.diffuse.rgb;
    vec3 specular = light.specular.rgb * spec * material.specular.rgb;
    return (ambient + diffuse + specular);
  }

  vec3 CalcPointLight(PointLight light , vec3 normal , vec3 frag_pos , vec3 view_dir) {
    vec3 light_dir = normalize(light.position.xyz - frag_pos);
    float diff = max(dot(normal , light_dir) , 0.f);

    vec3 reflect_dir = reflect(-light_dir , normal);
    float spec = pow(max(dot(view_dir , reflect_dir) , 0.0) , material.shininess);

    float distance = length(light.position.xyz - frag_pos);
    float attenuation = 1.f / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // vec3 ambient = material.ambient.rgb;
    vec3 ambient = light.ambient.rgb * material.ambient.rgb * attenuation;
    vec3 diffuse = light.diffuse.rgb * diff * material.diffuse.rgb * attenuation;
    vec3 specular = light.specular.rgb * spec * material.specular.rgb * attenuation;
    
    return (ambient + diffuse + specular);
  }

  void main () {
    /// general data
    vec3 norm = normalize(foe_normal);
    vec3 view_dir = normalize(fviewpoint - foe_position);

    /// lights
    // vec3 result = CalcDirLight(foe_dlight , norm , view_dir);
    vec3 result = vec3(0.f , 0.f , 0.f);
    
    int i = 0;
    for (; i < num_lights.x;) {
      result = result + CalcDirectionLight(direction_lights[i] , norm , view_dir);
      i = i + 1;
    }

    i = 0;
    for (; i < num_lights.y;) {
      result = result + CalcPointLight(point_lights[i] , norm , foe_position , view_dir);
      i = i + 1;
    }
      
    ///  final color
    FragColor = vec4(result , 1.f);
  };

}
