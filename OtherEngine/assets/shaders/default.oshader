vertex [mesh : default] {
  
  layout (std140 , binding = 0) uniform Camera {
    mat4 projection;
    mat4 view;
    vec3 viewpoint;
  };
   
  layout (std430 , binding = 1) readonly buffer ModelData {
    mat4 models[];
  };

  out vec3 fviewpoint;

  out vec3 foe_position;
  out vec3 foe_normal;
  
  void main() {
    gl_Position = projection * view * voe_model * vec4(voe_position , 1.0);

    fviewpoint = viewpoint;

    foe_position = vec3(voe_model * vec4(voe_position , 1.0));
    foe_normal = mat3(transpose(inverse(voe_model))) * voe_normal;
  };

}

fragment {
  
  in vec3 fviewpoint;

  in vec3 foe_position;
  in vec3 foe_normal;

  out vec4 FragColor;

  void main () {
    /// general data
    vec3 norm = normalize(foe_normal);
    vec3 light_dir = normalize(foe_plight.position - foe_position);
    vec3 view_dir = normalize(fviewpoint - foe_position);
    vec3 reflect_dir = reflect(-light_dir , norm);
    vec3 halfway_dir = normalize(light_dir + view_dir);

    float distance = length(foe_plight.position - foe_position);
    float attenuation = 1.f / (foe_plight.constant + foe_plight.linear * distance + foe_plight.quadratic * (distance * distance));

    /// ambient
    vec3 ambient = foe_plight.ambient * foe_material.ambient * attenuation;

    /// diffuse
    float diff = max(dot(norm , light_dir) , 0.0);
    vec3 diffuse = foe_plight.diffuse * (diff * foe_material.diffuse) * attenuation;

    /// specular
    float spec = pow(max(dot(norm , halfway_dir) , 0.0) , foe_material.shininess);
    vec3 specular = foe_plight.specular * (spec * foe_material.specular) * attenuation;
      
    ///  final color
    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result , 1.f);
    // FragColor.rgb = pow(FragColor.rgb , vec3(1.0/2.2));
  };

}
